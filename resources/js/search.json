[[{"l":"Welcome"}],[{"l":"Getting Started"},{"l":"Introduction","p":["The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to adapt to custom use cases. The framework supports a variety of inventory types, making it suitable for a wide range of games.","The predefined inventory types are:","List: A straightforward collection of items arranged as a list or a grid.","Equipment: Ideal for RPGs or games with wearable gear.","Grid(PRO): Supports items of varying sizes.","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs. It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","This framework is currently targeted at programmers. It lacks designer-friendly features such as custom editors or Scriptable Objects, so some coding is required to implement custom functionality."]},{"l":"Getting started","p":["To get started, check out the 2 demos included - \"Minimal\" and \"Basic\".","The Minimal demo has the least amount of code needed to setup a working inventory. It is a great starting point to familiarize yourself with the fundamentals of the framework. It consists of one inventory, some items and the simplest behavior of moving items around.","The Basic demo is a Minecraft-inspired inventory featuring the following:","A main inventory window consisting of equipment, inventory and a consumables hot-bar","A vendor window where you can buy pre-defined items and sell items from your inventory.","A treasure chest window, which has some items that you can pick but cannot place anything back. You can also pick all at once.","A crafting bench window, which has slots for materials and an outcome slot. Placing materials in the correct order will populate the outcome slot. Picking the item from outcome slot will \"craft\" the item.","A stash window, which is an inventory you can store items in.","A character sheet window","A way to drop items on the \"ground\".","A way to destroy items.","All this is integrated in a minimalistic 3d scene."]},{"l":"Installation","p":["You can install the package from Unity Package Manager. There are no external dependencies."]}],[{"l":"Core Concepts","p":["The framework is built around several key concepts that define its structure and behavior. Understanding these will help you make the most of its features."]},{"l":"Item","p":["An Item is a data type that represents an individual object in an inventory. It is highly flexible and comprises two main components:","Base: Contains fixed properties like ID, name, and icon path.","Data: Holds dynamic properties such as quantity or rarity.","This architecture is heavily inspired from RPGs like Diablo and Path of Exile but the separation ensures adaptability to fit various gameplay scenarios."]},{"l":"Slot","p":["A Slot is a container that can either hold an Item or remain empty. Slots can enforce restrictions, such as allowing only specific types of items, by providing a function ( Accepts) that operates on Item type.","The base Slot type is extended into specialized slot types:","ListSlot: Index-based storage.","SetSlot: Named slots for equipment/wearable items.","GridSlot( not available in Lite): Grid-based position storage."]},{"l":"Bag","p":["The Bag represents an inventory. It manages a collection of Slots. Each inventory type comes with its own behavior and can enforce restrictions on accepted items.","The base Bag type is extended into specialized types:","ListBag: Contains a list of ListSlots","SetBag: Contains a list of SetSlots","GridBag( PRO): Contains a 2D array of GridSlots as well as a list of GridItems"]},{"l":"Event Bus and Events","p":["The framework uses an Event Bus to decouple its components. Events are data containers describing actions, such as picking up an item. For example, a PickItem event includes the item itself, the source inventory and slot.","An event does not perform any actions itself, that falls under the responsibility of the Store."]},{"l":"Store","p":["Inspired by web technologies like Redux, the Store serves as the central hub for managing system state. It subscribes to events on event channels and performs necessary state updates. All changes to the system state flow through the Store, ensuring consistency and predictability."]},{"l":"Item Bases","p":["This is your repository of item bases and all the types that fully describe and categorize them. For example an Apple is defined as a stackable, consumable basic item, while a Dagger is a 1-handed weapon, with Attack Damage and Attack Speed"]},{"l":"Behaviors","p":["The UI is decoupled from any interactivity logic. All logic is abstracted away in behaviors, like showing a tooltip on hovering an item, dragging an item to pick it up or showing a \"ghost\" version of the dragged item."]}],[{"l":"Technical Details"},{"l":"Technical Details","p":["The framework takes a functional programming approach, emphasizing simplicity and separation of concerns. It uses the a common \"good\" practice of Composition over Inheritance and not so common convention of Rules over Conditions(pattern matching).","C# Records are used to model data types. They offer concise syntax, value-like behavior and are immutable by default. The immutability aspect is particularly useful for View Components, as it simplifies determining whether a re-render is necessary.","A type's behavior is implemented via extension methods to keep the data structures clean and focused. This prevents behavior inheritance, which is a big pain-point in classic OOP design.","To ensure proper input validation when creating new instances, each data type comes with one or more factory functions. For example, an Item can be created by providing both an ItemBase and an ItemData or just an ItemBase. In either case, the item Id will be automatically generated.","To represent the absence of an object the null object pattern is employed in favor of the classic null reference. This means that most types have an associated void type: Item = NoItem which acts like the identity element from algebra. One of the main advantages of this approach is that an operation can be performed on a an item or a collection of items without the need of a null check beforehand. An operation like this will have no effect on the item, if it is a NoItem."]},{"l":"UI Toolkit Integration","p":["The framework leverages UI Toolkit for rendering inventory views. It provides a declarative way to define elements, their data, and their styles using C# and USS, while completely avoiding UXML. The reason for bypassing UXML is that data binding, referencing elements and working with the UXML asset, all come with levels of verbosity and complexity that drastically slow down productivity. This means, however, that the included visual components (inventories, windows, slots) cannot be viewed in Unity's UI Builder. You can still use the UI Builder to design own custom components if you prefer so. Since UI Toolkit is heavily based on web technologies, the framework proposes web-inspired nomenclature, such as:","DOM: Utility functions for managing elements.","DIV: A shorthand alias for VisualElement."]},{"l":"How it works","p":["From a birds eye view, the system consists of a data store, an event bus and UI When the user interacts with the UI, let's say picks an item from a slot, an event is put on the event bus.","The Store, having subscribed to the event, sends its data to a handler function which will update the bag.","Then, any view that is observing the bag will update itself."]}],[{"l":"How to use"},{"l":"How to use the demos","p":["The demos serve both as a showcase of what's possible and as a solid starting point for a custom inventory system. They are designed to be copied into projects and modified as needed. You can start with the Minimal version and add the features you need, or with Basic(I might rename this to Minecraft if the Asset Store allows it) and trim what you don’t need while adding your own features. When copying the whole thing, refactor/rename the namespaces in all files to something that makes sense to you. Some demos may include files that have the demo name in their names. You should rename those too, for consistency. Some editors may help you with automating this but I don't even bother and do it by hand - there aren't that many files."]},{"i":"how-do-you-decide-what-you-need","l":"How do you decide what you need?"},{"l":"The Store","p":["First, there’s the Store, which is the central place where data is stored and handled. The Store must listen to at least two events— pick item and place item. Handlers for these events pass the data to Core functions for processing. Check either demo for examples of this. For instance, in Basic, moving an item between inventories (such as with ctrl+click), is handled in the on pick event handler.","The Store must also track the currently dragged item, which is an ObservableItem. Why an observable? So that different parts of the system can react to changes without needing to explicitly subscribe to a Dragged Item Changed event. The Store is a singleton, and that’s fine—everything in it is read-only."]},{"l":"The Type System and Items","p":["You will need to enhance the type system to fit to your needs. The Minimal demo doesn’t expand on the type system and directly creates items in the Store. However, Basic introduces additional base types and adds Rarity to item data (see Basic/Inventory/Types.cs).","All items have quantity and stackable fields—these seemed like the only universally shared properties across all inventory types. Another common property is the icon path, which is also included in base item data.","Why are items split into Base and Data? This follows the Flyweight pattern, an efficient design pattern that embraces composition over inheritance. For example, an Apple instance doesn’t need to carry redundant, unchanging data like its icon or description—it can reference a shared base instead."]},{"l":"The UI System","p":["You will need a UI Document attached to a GameObject in your scene, a Panel Settings asset, a Root UXML asset, and a script to attach the inventory’s root to the document.","You can start with the built-in renderers for items, slots, and \"bags\" (inventories) and create custom views as needed. For example, in the Basic demo, the custom BasicItemView is a copy of ItemView with an extra background element to reflect item rarity. You could argue that it should extend the base instead, but for components this small, it's not worth the trouble. More on this later.","You're expected to create custom views for your inventory screens and windows, using a mix of built-in and custom views alongside other UI elements like buttons and text. For an example, see Basic/Views/ChestWindow.cs. It uses the built-in ListBag renderer and adds a button to collect all items.","The UI should mainly define structure and styling, with minimal behavior (such as reacting to button clicks). Core logic is abstracted into extension methods (see the next section for details).","Each demo includes a Theme file (see Resources/Basic/BasicTheme.tss). Technically, you could use the default theme, but it's quite ugly, and you’ll likely customize it anyway.","Most styling is consolidated into a single large USS file ( BasicStyling.uss). Although not the cleanest approach, I found it easier to search for selectors in one big file rather than looking in many smaller ones. If some styles are unrelated to the rest, you can move them into separate files and import them into the theme (see BasicTooltip.uss). This is just a suggestion—organize your styles however makes the most sense to you.","If something looks off, a missing or incorrect style is likely the cause. To help with debugging, each demo includes a window that displays the raw state of the Store. To open it, go to Tools Basic Debug. You’re expected to modify this window (through code, of course, see Basic/Editor/Debug.cs) and add any extra data you need to observe."]},{"l":"Behaviors and Interactions","p":["You’ll need to attach behaviors to the root layer of your UI document (see Basic/Views/RootLayer.cs). These behaviors handle visual interactions, such as showing the dragged item or displaying tooltips on hover (see Core/Behaviors/Behaviors.cs) .","For example, WithRestrictedSlotBehavior observes the dragged item and reacts to mouse over/out events on all SlotViews. It checks whether the slot accepts the dragged item (defined when the slot is created) and visually marks the slot as legal or illegal by adding a USS class ( legal-action). This applies a red or green overlay on the slot (assuming the relevant styles are defined).","In order to be able to pick (and place) items and see them move you will need to add a pick and a ghost item behavior. Currently there are two pick behaviors and one ghost behavior defined (placing is also defined in the pick behavior):","WithClickToPickBehavior will pick an item on mouse down","WithDragToPickBehavior will pick an item when it was dragged a minimum amount of pixels ( 32 by default), as well as on mouse up","WithGhostItemBehavior watches mouse for movement and renders a view of the dragged item."]}],[{"l":"Troubleshooting"},{"l":"UI Toolkit Debugger","p":["Since UI Toolkit uses a form of CSS, it also inherits all the downsides of the cascading aspect - always check for unintended style propagation affecting your UI.","Use the UI Toolkit Debugger ( Window UI Toolkit Debugger) to inspect the visual elements tree and its styles and classes."]},{"l":"Built-in Debugger","p":["Use the included Debug editor windows to view the raw state of the system. These tools help identify whether issues originate from the data layer or the view layer."]},{"l":"Discord Server","p":["Join the Discord server for additional support from myself and the community."]}],[{"l":"FAQ"}],[{"l":"Roadmap","p":["Various optimizations","PRO version"]}],[{"l":"Live Demos"},{"l":"Live Demos"}],[{"l":"ARPG"}],[{"l":"Backpack"}],[{"l":"Basic"}],[{"l":"Unnamed Game"}]]