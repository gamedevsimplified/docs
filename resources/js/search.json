[[{"l":"Inventory Framework","p":["✔️ Features","A versatile and extensible framework for creating inventories using UI Toolkit.","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs.","Buy/Sell/Drop/Destroy","Character Sheet","Chests","Crafting","Ctrl+Click to Move","Drag and drop","Equipment","Hotbar","It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","Item cost","Item Rarity","Save/Load Player Data","Shop","Sounds","The framework supports a variety of inventory types, making it suitable for a wide range of games.","The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to extend and adapt to custom use cases.","This package is targeted at programmers but can be used by non programmers. Some coding is still required to implement custom functionality.","Tooltip"]}],[{"l":"Getting started"},{"l":"Introduction","p":["The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to adapt to custom use cases. The framework supports a variety of inventory types, making it suitable for a wide range of games.","The predefined inventory types are:","List: A straightforward collection of items arranged as a list or a grid.","Equipment: Ideal for RPGs or games with wearable gear.","Grid(PRO): Supports items of varying sizes.","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs. It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","This framework is currently targeted at programmers. It lacks designer-friendly features such as custom editors or Scriptable Objects, so some coding is required to implement custom functionality."]},{"l":"Getting started","p":["To get started, check out the 2 demos included - \"Minimal\" and \"Basic\".","The Minimal demo has the least amount of code needed to setup a working inventory. It is a great starting point to familiarize yourself with the fundamentals of the framework. It consists of one inventory, some items and the simplest behavior of moving items around.","The Basic demo is a Minecraft-inspired inventory featuring the following:","A main inventory window consisting of equipment, inventory and a consumables hot-bar","A vendor window where you can buy pre-defined items and sell items from your inventory.","A treasure chest window, which has some items that you can pick but cannot place anything back. You can also pick all at once.","A crafting bench window, which has slots for materials and an outcome slot. Placing materials in the correct order will populate the outcome slot. Picking the item from outcome slot will \"craft\" the item.","A stash window, which is an inventory you can store items in.","A character sheet window","A way to drop items on the \"ground\".","A way to destroy items.","All this is integrated in a minimalistic 3d scene."]},{"l":"Installation","p":["You can install the package from Unity Package Manager. There are no external dependencies."]}],[{"l":"Core Concepts","p":["The framework is built around several key concepts that define its structure and behavior. Understanding these will help you make the most of its features."]},{"l":"Item","p":["An Item is a data type that represents an individual object in an inventory."]},{"l":"ItemBase","p":["ItemBase contains fixed properties like name, icon path and stacking info.","This architecture is heavily inspired from RPGs like Diablo and Path of Exile but the separation ensures adaptability to fit various gameplay scenarios."]},{"l":"Slot","p":["A Slot is a container that can either hold an Item or remain empty. Slots can enforce restrictions, such as allowing only specific types of items, by providing a function ( Accepts) that operates on Item type.","The base Slot type is extended into specialized slot types:","ListSlot: Index-based storage.","SetSlot: Named slots for equipment/wearable items.","GridSlot(PRO): Grid-based position storage."]},{"l":"Bag","p":["The Bag represents an inventory. Each inventory type comes with its own behavior and can enforce restrictions on accepted items.","The base Bag type is extended into specialized types:","ListBag: Contains a list of ListSlots","SetBag: Contains a list of SetSlots","GridBag(PRO): Contains a 2D array of GridSlots as well as a list of GridItems"]},{"l":"Event Bus and Events","p":["The framework uses an Event Bus to decouple its components. Events are data containers describing actions, such as picking up an item. For example, a PickItem event includes the item itself, the source inventory and slot.","An event does not perform any actions itself, that falls under the responsibility of the Store."]},{"l":"Store","p":["Inspired by web technologies like Redux, the Store serves as the central hub for managing system state. It subscribes to events on event channels and performs necessary state updates. All changes to the system state flow through the Store, ensuring consistency and predictability."]},{"l":"Item Bases","p":["This is your repository of item bases and all the types that fully describe and categorize them. For example an Apple is defined as a stackable, consumable basic item, while a Dagger is a 1-handed weapon, with Attack Damage and Attack Speed"]},{"l":"Behaviors","p":["The UI is decoupled from any interactivity logic. All logic is abstracted away in behaviors, like showing a tooltip on hovering an item, dragging an item to pick it up or showing a \"ghost\" version of the dragged item."]}],[{"l":"Technical Details"},{"l":"Functional programming","p":["The framework takes a functional programming approach, emphasizing simplicity and separation of concerns. It uses the a common \"good\" practice of Composition over Inheritance and not so common convention of Rules over Conditions(pattern matching)."]},{"l":"Records","p":["C# Records are used to model data types. They offer concise syntax, value-like behavior and are immutable by default. The immutability aspect is particularly useful for View Components, as it simplifies determining whether a re-render is necessary."]},{"l":"Extension methods","p":["A type's behavior is implemented via extension methods to keep the data structures clean and focused. This prevents behavior inheritance, which is a big pain-point in classic OOP design."]},{"l":"Factories","p":["To ensure proper input validation when creating new instances, each data type comes with one or more factory functions. For example, in Basic demo, an Item can be created by providing just an ItemBase, or ItemBase and Quant, or ItemBase, Quant and Rarity"]},{"l":"Null object","p":["To represent the absence of an object the null object pattern is employed in favor of the classic null reference. This means that most types have an associated void type: Item = NoItem which acts like the identity element from algebra. One of the main advantages of this approach is that an operation can be performed on a an item or a collection of items without the need of a null check beforehand. An operation like this will have no effect on the item, if it is a NoItem."]},{"l":"UI Toolkit","p":["The framework leverages UI Toolkit for rendering inventory views. It provides a declarative way to define elements, their data, and their styles using C# and USS, while completely avoiding UXML. The reason for bypassing UXML is that data binding, referencing elements and working with the UXML asset, all come with levels of verbosity and complexity that drastically slow down productivity. This means, however, that the included visual components (inventories, windows, slots) cannot be viewed in Unity's UI Builder. You can still use the UI Builder to design own custom components if you prefer so. Since UI Toolkit is heavily based on web technologies, the framework proposes web-inspired nomenclature, such as:","DOM: Utility functions for managing elements.","DIV: A shorthand alias for VisualElement."]}],[{"l":"Core API \uD83D\uDEA7"},{"l":"Bag","p":["use BagExt static class if function is not an extension method"]},{"l":"AddItems","p":["Adds Items to a Bag."]},{"l":"PickItem","p":["Picks an Item from a Bag."]},{"l":"PlaceItem","p":["Places an Item in a Bag."]},{"l":"MoveItem","p":["Moves Items from a Bag to another target Bag."]},{"l":"PickOrMoveItem","p":["Picks an item from the source bag, or moves it to the target bag if Ctrl is held.","Returns a failed result if moving but no target bag is provided."]},{"l":"ItemBase"},{"l":"Create","p":["Creates an Item from an ItemBase"]},{"l":"Item"},{"l":"Clone","p":["Clones an Item and returns it."]},{"l":"Size","p":["Returns Item Size if it's a ShapeItem or a 1x1"]},{"l":"SetQuant","p":["Creates a new Item with the specified quantity."]},{"l":"Decrement","p":["Creates a new item with quantity decreased by 1."]},{"l":"StackAll","p":["Moves all quantity from source item to target item."]},{"l":"StackOne","p":["Decrements source Item quantity and increments target Item quantity."]},{"l":"UnstackHalf","p":["Splits a stack in half."]},{"l":"CanStack","p":["Checks if an Item can be stacked onto another Item."]},{"l":"Slot"},{"l":"IsEmpty","p":["Returns true if Slot is empty."]},{"l":"IsFull","p":["Returns true if Slot is not empty."]},{"l":"Clear","p":["Returns a new empty Slot."]}],[{"l":"Troubleshooting"},{"l":"UI Toolkit Debugger","p":["Since UI Toolkit uses a form of CSS, it also inherits all the downsides of the cascading aspect - always check for unintended style propagation affecting your UI.","Use the UI Toolkit Debugger( Window UI Toolkit Debugger) to inspect the visual elements tree and its styles and classes."]},{"l":"Built-in Debugger","p":["Use the included Debug windows ( Tools GDS Basic Debug) to view the raw state of the system.","These tools help identify whether issues originate from the data layer or the view layer."]},{"l":"Discord Server","p":["Join the Discord server for additional support from myself and the community."]}],[{"l":"Roadmap","p":["Various optimizations (pool events, change detection)","Add item sorting to Core","Add Scriptable Objects support","Improve Editor support","Enhance demos","Add a mobile demo"]}],[{"l":"Quick Setup","p":["This setup uses the Basic template as an example.","To quickly add an inventory to your scene, locate the Inventory prefab in one of the demo/example Prefabs folders and drag it into your scene."]},{"l":"1. Add the Inventory prefab","p":["Navigate to the desired demo folder ( GDS/Demos/Basic in this example), and drag the Inventory prefab from the Prefabs folder into your scene hierarchy."]},{"l":"2. Link the Player Transform","p":["If you don't already have a Player object in your scene, create a Cube and name it Player.","Select the Inventory object in the scene, expand the InventoryEvents component, and drag the Player object from the hierarchy into the Player Transform field.","Items dropped on the ground will spawn at random positions around the Player."]}],[{"l":"Manual Setup (Recommended)","p":["This setup uses the Basic template as an example. If you're using a cloned template, apply the same steps to your version instead.","You can manually integrate a demo template into your scene by following these steps:"]},{"l":"1. Add a UI Document","p":["To add a UI Document, right-click the hierarchy and select UI Toolkit UI Document."]},{"l":"2. Assign UI Assets","p":["Select the UI Document object in the scene. Navigate to the desired demo folder ( GDS/Demos/Basic in this example), and drag the Panel Settings and Visual Tree Asset into their corresponding fields in the UI Document component.","These assets handle styling and layout."]},{"l":"3. Add Inventory Scripts","p":["Go to Demos/Basic/Scene/Scripts and add the InventoryEvents and InventoryInput scripts to the UI Document object.","InventoryEvents handles item spawning when dropped and cleanup when picked up.","InventoryInput listens for keyboard input and forwards it to the inventory."]},{"l":"4. Assign the Player Transform","p":["If you don't already have a Player object in the scene tree, create a cube and name it Player.","Select the UI Document, expand the InventoryEvents component and drag the Player object from the scene into the Player Transform field."]},{"l":"5. Assign Item and VFX Prefabs","p":["Go to Common/Prefabs and drag WorldItem prefab into the Item Prefab field and PickupVFX prefab into the PickupVFX field.","Items dropped on the ground will spawn at random positions around the Player.","You can adjust the Drop Radius and Drop Offset here."]}],[{"l":"Add new items"},{"l":"Add new item bases","p":["New item types can be added by defining additional fields in the Bases.cs file.","Each field represents a new item base that becomes part of the system.","For now, this is a manual process, but in the future it may be driven by a ScriptableObject or a server request."]},{"l":"Add new initial items","p":["To add a new initial item to an inventory, update the appropriate variable in Store/InitialState.cs.","For example, the following adds a stack of 20 Mana Potions to the Hotbar.","The initial state is applied when the inventory is first initialized or reset.","The Mana Potion should appear in the Hotbar"]},{"l":"Add a Store Component to a GameObject","p":["The Basic template allows you to attach an inventory to a GameObject and add items directly in the editor.","In this example, we define a Chest containing 3 items:","Select an \"interactive object\" in the scene.","Remove the StoreBag script.","Add the WorldBag script (from Basic/Scripts).","Specify a Bag ID and Type.","Set size and add items.","Add items to a Chest"]}],[{"l":"Add Item weight","p":["This setup uses the Basic template as an example. If you're using another template, apply the same steps to your version instead.","If your game uses an Encumbrance system where item weight matters, you can extend a template to support it."]},{"l":"1. Extend ItemBase","p":["Add a Weight field to ItemBase.","Expose a Weight property in BasicItem that returns the base item's weight."]},{"l":"2. Set Weights for Item Bases","p":["For each item base that should have weight, assign an appropriate value to its Weight field."]},{"l":"3. Show Weight in Tooltips","p":["To display item weight in the tooltip, update the Tooltip view.","This example uses a label but you can use an icon instead.","The Weight should show up in the Tooltip"]},{"l":"4. Compute Total Weight","p":["In order to show the total weight in the Character Sheet view, we need to add it to CharacterSheet class and recompute on equipment change."]},{"l":"5. Update Character Sheet Window","p":["Finally, update the CharacterSheetWindow class to show the total weight.","As a bonus, you can add color-coded encumbrance levels based on custom ranges — tweak these thresholds as needed.","The Total Weight should show up in the Character Sheet"]}],[{"l":"Clone a template","p":["This is a manual process at the moment but will be automated in a future update.","We'll be cloning Basic template in this example and naming it MyGame.","If you are basing your work on one of the templates (demos), I recommend you clone it to avoid eventual conflicts when upgrading to a newer version of the package. It is also handy to keep the original version as a reference."]},{"l":"1. Create a new folder","p":["Create a new folder in Assets and name it MyGame."]},{"l":"2. Copy files","p":["Go to GDS/Demos/Basic and copy everything except Editor, Prefab, and the Scenes into MyGame."]},{"l":"3. Update the Assembly Defnition Asset","p":["Go to MyGame and change the asset name and the assembly name in the inspector from GDS/Demos/Basic to MyGame.","Don't forget to press Apply!"]},{"l":"4. Update the namespace","p":["To fix the naming conflicts, rename the existing namespace GDS.Demos.Basic to something appropriate for your project ( MyGame in this example). Most IDEs offer batch renaming tools that safely update all references.","Make sure to limit the search scope to MyGame folder only."]},{"l":"5. Rename Assets and Folders","p":["Rename Panel Settings and the Visual Tree assets to MyGame.","Go to Resources and rename Basic folder to MyGame","Go to Resources/MyGame and rename BasicTheme to MyGameTheme"]},{"l":"6. Update Panel Settings stylesheet","p":["Go to MyGame, select the Panel Settings asset and update the Theme Style Sheet with Resources/MyGame/MyGameTheme"]},{"l":"7. Create a new Scene","p":["Create a new Scene and name it MyGame."]},{"l":"8. Add an Inventory","p":["Continue by following this tutorial to add an inventory to a scene."]}],[{"l":"Use New Input System","p":["This guide walks you through integrating the Inventory asset with Unity's New Input System.","This guide uses the Basic template as an example.","Prerequisites:","Input System package installed.","Input Actions asset created."]},{"l":"0. Check Input Settings","p":["Go to Edit > Project Settings, then navigate to Player > Other Settings > Configuration, and set Active Input Handling to Both.","This is a temporary workaround until the project is fully migrated to the new Input System.","If using this workaround isn’t a suitable option, feel free to contact me (on Discord) for guidance on making the asset work exclusively with the new Input System."]},{"l":"1. Define Input Actions","p":["Open the Input Actions asset.","Add a new Action Map with the following actions:"]},{"l":"2. Attach PlayerInput component","p":["Select the Inventory object in the scene and add a PlayerInput component.","Note the function names in the Behavior: Send Messages section. We will use these functions to pass the events down to the Store."]},{"l":"3. Implement a new Input Handling Script","p":["In your Assets folder create a new MonoBehaviour script and name it NewInventoryInput"]},{"l":"4. Replace InventoryInput script","p":["Select the Inventory object in the scene, remove the old InventoryInput script and add NewInventoryInput."]}],[{"l":"Customize Style","p":["This setup uses the Basic template as an example."]}],[{"l":"Live demos","p":["Basic","Starter Template","ARPG","Backpack","Unnamed Game"]}],[{"l":"ARPG"}],[{"l":"Backpack"}],[{"l":"Basic"}],[{"l":"Starter Template"}],[{"l":"Unnamed Game","p":["A \"backpack\" inventory proof of concept built on top of a mock-up by Yab Ninja(author and game creator)"]}]]