[[{"l":"Inventory Framework v2","p":["A versatile and extensible framework for creating inventories using UI Toolkit.","The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to extend and adapt to custom use cases.","The framework supports a variety of inventory types, making it suitable for a wide range of games.","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs.","It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","This package is targeted at programmers but can be used by non programmers. Some coding is still required to implement custom functionality."]}],[{"l":"Introduction","p":["Inventory Framework draws inspiration from games like Minecraft, Dark Souls, Witcher 3, Diablo II, Path of Exile, Backpack Battles, DayZ, and Escape from Tarkov.","The demos included in the package emulate behaviors from these games to a degree. The goal being to demonstrate the flexibility of the underlying architecture."]},{"l":"Features and mechanics","p":["and slot restriction based on item type.","are not part of the core domain and instead are provided as example/demo implementations meant to be studied, extended and adapted.","buying and selling,","container items (items that hold other items),","Core behaviors include","crafting,","drag-and-drop,","dropping items and spawning prefabs,","equipping items,","Features and mechanics like these are deceptively complex. Supporting rotation, collision checks, spatial validation and visual feedback typically requires a significant engineering effort. The framework abstracts much of this complexity away.","Inventory Tetris","item rotation (for grid-based inventories),","item stacking and splitting,","Other common mechanics such as","The framework covers typical features one might expect from an inventory system, while avoiding rigid assumptions about how your game should behave.","The framework supports both list-based inventories, where each item occupies a single cell (Minecraft), and grid-based inventories, where items can have rectangular or irregular shapes. This enables game-defining mechanics such as \"inventory Tetris\" (Backpack Battles, Diablo).","These mechanics work out of the box and are designed to be composed and extended.","tooltips,"]},{"l":"UI Toolkit","p":["UI Toolkit is the UI system of choice (for now). It is well-suited for inventory interfaces, due to it's declarative nature and built-in flexible layout system.","UI Builder allows you to iterate on styling and layout without recompilation, which significantly improves workflow when designing inventory screens. Styling through themes and USS rules can be extremely powerful, though it sometimes introduces its own challenges when managing specificity and debugging style conflicts.","Transitions (scale, rotation), hover states (border on mouse over), and runtime theme switching come \"for free\" in UI Toolkit as opposed to traditional GameObjects and Prefabs.","That being said, UGUI is still a thing and support for it is on the roadmap!","UI Builder","If you are new to UI Toolkit, use these introductory videos to get you started."]}],[{"l":"Getting Started","p":["The best way to get started is by exploring the demos and examples.","Examples are isolated implementations of various use-cases. The idea is to separate the solution to a problem from all the potential noise. Examples are broken down by complexity into basic, intermediate, advanced (and grid, in PRO version), ranging from the simplest list inventory to container items and crafting benches. More examples will be added over time.","Examples List"]},{"l":"Example structure","p":["A typical example consists of a:","Scene","UI Document","Controller","Store","Minimal Example","Files are prefixed with the example name to prevent naming conflicts and to keep the examples self-container. This structure also makes it easier to copy an example into your own project and adapt it incrementally.","Some examples introduce custom behavior by extending the Store. For instance, splitting a stack or moving an item, are typically implemented inside a custom, reusable Store. You can read more about this in Architecture Overview."]},{"l":"How to use","p":["The recommended approach is to build your functionality by composing and extending existing pieces rather than modifying the framework code directly. Avoid editing demo code in place as updates to the package may overwrite your changes. Instead, treat the provided implementations as references and starting points.","Start by scaffolding your item system. Identify what is fixed (shared properties) and what differentiates items (stats, behaviors, categories). Create new Items and ItemBases for each meaningful item type. This allows you to define rule-based logic, like showing different tooltips for weapons versus armor, or preventing certain item types from being placed into specific equipment slots.","Next, identify which type of inventories your game should support - player inventory, stash, equipment, shop, crafting interface, etc. Create distinct types for each sufficiently different screen. This separation enables rule-driven behavior based on context: where an item originates, where it is placed, and what actions are permitted between those contexts.","For basic interactions, reuse an existing Store implementation. When your design requires new rules or workflows, create a custom Store derived from an example.","Introduce new Event types when necessary. For example, the Basic demo adds a custom event triggered after a successful crafting operation. That event is then consumed by a separate SFX controller to play a \"crafting\" audio clip.","Finally, create your UI Document and Controller, wire them together with your Store, and start with simple interactions between inventories. Add UI toggles, feedback, and additional views gradually. Iterate."]},{"l":"Guides","p":["To get started, check this guided timelapse of creating a simple inventory."]}],[{"l":"Architecture Overview \uD83D\uDEA7"},{"l":"Overview","p":["Bag Views update themselves in response to data changes.","Bags → hold data","Bags are collections of slots with rules defining what items can be stored and how.","Bags are typically defined in Controllers.","Bags notify any subscribers of data change (typically Bag Views).","Controllers → wire everything together","Controllers are MonoBehaviors.","Controllers query the UI Document for Bag Views, initialize them and attach Manipulators.","Here's a bottom-up bird's-eye view of the architecture:","Items are defined as Scriptable Objects.","Items are stored in collections called Bags (List, Set, Grid).","Manipulators → add UI Interaction Behaviors","Manipulators implement behaviors (drag-and-drop, tooltip).","Manipulators react to user input and publish events on the Event Bus.","Scripts other than the Store, can listen to events on the Event Bus and trigger their own behavior (play sounds, spawn objects).","Stores → define rules and mutate data","The Event Bus is a one-way messaging mechanism that decouples UI from logic and data.","The Event Bus is declared in the Store.","The framework follows a data-driven, event-based architecture. It keeps the data, logic and UI separate.","The Store behaves like a Singleton (it was a Singleton in v1).","The Store is a Scriptable Object.","The Store is the sole authority over data mutation.","The Store processes events and updates the Bags (either passed as event parameters or from its own context).","The system follows a unidirectional flow: user input generates events, the Store processes them, state updates, and views react to changes:","To sum up here are the major components and their responsibilities:","Views → render UI"]},{"l":"Item System","p":["Item systems in games vary significantly in scope and complexity. Some games feature complex systems with multiple item categories (weapons, armor, consumables), subtypes, rarity tiers, affixes, requirements, etc. Other games use colored shapes and nothing else.","To allow such variety, the item system was designed to be as abstract and as extensible as possible.","At a minimum, an item defines:","an icon","whether it is stackable","maximum stack size","current stack size","Items in games typically consist of a fixed part and a dynamic part. For example, in Path of Exile a body armor has a base that defines immutable properties (icon, armor range, attribute requirements), while instance-specific values include the actual armor roll, rarity and affixes. In contrast, in Backpack Battles, items are entirely static except for their orientation within the inventory.","This structural separation is known as the Flyweight pattern: shared immutable data is stored once, while instance-specific state is stored separately.","In our case, the fixed part of the Item is a type called ItemBase, which consist of the icon, the stackable flag and maximum stack size. The Item itself stores the current stack size.","You can bridge an existing item system with Inventory Framework. A guide for that will be added soon. In the meantime, reach out on Discord."]},{"l":"ItemBase","p":["ItemBase is implemented as a ScriptableObject. It describes what an item is, and not how it bahaves.","Each ItemBase has a factory method responsible for creating and initializing an Item instance of the associated type.","For example, in the Basic Demo, the Axe ItemBase has a fixed attack damage range. Upon instantiation, the Axe instance will roll attack damage from its base attack range and store in AttackDamage property.","To extend the functionality of an Item, extend the ItemBase and override the factory method. For example, all items in the Basic demo have a fixed Weight and Cost, but variable Rarity:","This ensures they are visible in the Unity Editor and persist correctly between scene reloads.","Create as granular a hierarchy as your game requires. A useful rule of thumb: if certain properties only apply to a subset of items, consider introducing a more specific type.","Example hierarchy from the Basic Demo:","Item","BasicItem (weight, cost, rarity)","BasicWeapon (damage)","BasicArmor (defense)"]},{"l":"Tag","p":["Tag is ScriptableObject marker type (it contains no properties). Tags enable flexible constraints, such as restricting a Slot or a Bag to specific item types. This is achieved by intersecting tag sets. They are defined as ListTag on ItemBase, Slot and Bag types."]},{"l":"Bag","p":["A Bag is pure data container. It represents a well-defined slice of your game state and should be treated as the single source of truth for that slice.","Bag is an abstract class that defines the contract and shared behavior common to all bags, without enforcing any specific storage model. All state-changing behavior is implemented in concrete subclasses.","The three primary implementations are ListBag, SetBag and GridBag.","Bags expose public methods to add, remove, or modify items. By convention, bag state should be mutated from a single place (for example, the Store, or main controller). This prevents hidden side effects and keeps state transitions explicit and predictable.","Bags emit change events when their state mutates. Other systems, such as UI views, gameplay systems, or persitence layers subscribe to these events and react accordingly (re-render or recompute internal state). For example, ListBagView listens to ItemChanged event on a ListBag. When raised, it re-renders only the affected slot. This keeps rendering logic decoupled from state mutation and avoids unnecessary full refreshes.","A Bag can be declared in a MonoBehaviour (state resets when exiting Play Mode), or in a ScriptableObject (state persists after Play Mode and can be reset manually)."]},{"l":"ListBag","p":["ListBag behaves like a fixed-size list. It contains an ordered collection of slots, indexed by position. In a ListBag, item size and spatial footprint is irrelevant.","ListBag is typically used when:","order matters (hotbar, quick access list)","layout is purely visual (can be displayed horizontally, vertically or as a grid)","all items occupy a single logical slot (1x1)"]},{"l":"SetBag","p":["SetBag behaves conceptually like a dictionary. It maps predefined slot keys to item content.","Slots are identified by semantic keys (Helmet, Weapon, Ring).","Slot identity is more important than position","A Slot typically enforces constraints on what it can accept.","SetBag is typically used in Equipment systems."]},{"l":"GridBag","p":["GridBag models a two-dimensianal spatial container. Unlike ListBag, layout is not purely representational. Spatial structure becomes part of gameplay, allowing players to optimize positioning and capacity.","Items occupy multiple cells.","Placement requires spatial validation.","Position and orientation matter."]},{"l":"Store","p":["Stores contain the logic of the system.","A Store:","Listens to events (e.g., Pick, Place, Drop)","Applies validation rules","Updates Bags","Publishes result events","For example, a Store decides whether an item can be moved, whether stacks can merge, what happens when an item is dropped into the world.","Stores define what is allowed, but they do not render anything. This makes behavior easy to customize — you can swap or extend Stores without changing Views."]},{"l":"Manipulator","p":["Manipulators are small, reusable interaction components attached to the root visual element. They are responsible for translating user input into high-level intent.","For example, Manipulators enable behaviors such as:","Drag and drop","Tooltips","Item rotation","Right-click / double-click actions","Slot highlighting","A Manipulator typically:","Listens to pointer or keyboard events.","Applies activation rules (e.g., modifier keys, mouse buttons).","Publishes an event to the event bus.","Importantly, Manipulators do not modify Bags directly. They only interpret input and emit intent."]},{"l":"Controller","p":["Controllers do not define gameplay rules. They simply connect the parts of the system together.","They:","Create or reference Bags","Inject Bags into Stores","Bind Bags to Views","Attach behavior in form of Manipulators"]},{"l":"Event Bus","p":["The event bus allows systems to communicate without direct references.","For example:","A Manipulator publishes a \"Pick\" event.","The Store reacts and updates a Bag.","The View re-renders automatically.","A sound system listens and plays an effect.","Because everything communicates through events:","Features can be added without modifying core systems.","Sound, VFX, and world spawning remain optional.","The framework stays modular and extensible."]}],[{"l":"Troubleshooting \uD83D\uDEA7"},{"l":"Discord Server","p":["Join the Discord server for additional support from the developer and the community."]},{"l":"Document doesn't look right in UI Builder","p":["If you open a document in UI Builder and it looks like it doesn't have the right styling, make sure to select the right theme from the dropdown.","Each demo comes with its own theme, grid examples use GDS Grid, and the rest - GDS Default.","In rare cases, themes may become corrupted during import. This is usually caused by an invalid asset path or GUID mismatch. If this occurs, please contact the developer for assistance."]},{"l":"Objects in the scene do not react to pointer","p":["Add Physics Raycaster component to main camera.","Add EventSystem component to scene hierarchy.","Make sure the UI Document is not blocking input. Try setting the blocking element's PickingMode to Ignore."]},{"l":"Bag doesn't show up in the inspector","p":["Make sure the class is marked as Serializable."]}],[{"l":"Roadmap","p":["Add support for UGUI","Add (some) controller support/examples","Various optimizations (pool events, change detection)","Add item sorting to Core","Enhance demos","Add a mobile demo","Improve Editor support","Add Scriptable Objects support"]}],[{"l":"v1 Docs","p":["The old website was moved here"]}],[{"l":"Bag \uD83D\uDEA7","p":["Bag is the abstract base class for all inventory containers. It defines the common contract for storing, validating, and manipulating Item instances. The base implementation intentionally does very little — most methods return Fail or Success by default. Concrete implementations (e.g., ListBag, GridBag) provide the actual behavior. Derived classes are expected to override the relevant methods."]},{"l":"CanAdd"},{"l":"CanRemove"},{"l":"Add"},{"l":"AddAt"},{"l":"AddRange"},{"l":"Remove"},{"l":"TransferAll"},{"l":"TransferOne"},{"l":"SplitHalf"}],[{"l":"ListBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"SetBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"GridBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"ItemAdded"},{"l":"ItemRemoved"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"Live demos","p":["Basic","Starter Template","ARPG","Backpack","FPS-Survival","Unnamed Game"]}],[{"l":"ARPG"}],[{"l":"Backpack"}],[{"l":"Basic"}],[{"l":"FPS Survival"}],[{"l":"Starter Template"}],[{"l":"Unnamed Game","p":["A \"backpack\" inventory proof of concept built on top of a mock-up by Yab Ninja (author and game creator)"]}]]