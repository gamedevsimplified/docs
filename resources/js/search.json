[[{"l":"Inventory Framework v2","p":["A versatile and extensible framework for creating inventories using UI Toolkit.","The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to extend and adapt to custom use cases.","The framework supports a variety of inventory types, making it suitable for a wide range of games.","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs.","It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","This package is targeted at programmers but can be used by non programmers. Some coding is still required to implement custom functionality."]}],[{"l":"Introduction","p":["Inventory Framework draws inspiration from games like Minecraft, Dark Souls, Witcher 3, Diablo II, Path of Exile, Backpack Battles, DayZ, and Escape from Tarkov.","The demos included in the package emulate behaviors from these games to a degree. The goal being to demonstrate the flexibility of the underlying architecture."]},{"l":"Features and mechanics","p":["and slot restriction based on item type.","are not part of the core domain and instead are provided as example/demo implementations meant to be studied, extended and adapted.","buying and selling,","container items (items that hold other items),","Core behaviors include","crafting,","drag-and-drop,","dropping items and spawning prefabs,","equipping items,","Features and mechanics like these are deceptively complex. Supporting rotation, collision checks, spatial validation and visual feedback typically requires a significant engineering effort. The framework abstracts much of this complexity away.","Inventory Tetris","item rotation (for grid-based inventories),","item stacking and splitting,","Other common mechanics such as","The framework covers typical features one might expect from an inventory system, while avoiding rigid assumptions about how your game should behave.","The framework supports both list-based inventories, where each item occupies a single cell (Minecraft), and grid-based inventories, where items can have rectangular or irregular shapes. This enables game-defining mechanics such as \"inventory Tetris\" (Backpack Battles, Diablo).","These mechanics work out of the box and are designed to be composed and extended.","tooltips,"]},{"l":"UI Toolkit","p":["UI Toolkit is the UI system of choice (for now). It is well-suited for inventory interfaces, due to it's declarative nature and built-in flexible layout system.","UI Builder allows you to iterate on styling and layout without recompilation, which significantly improves workflow when designing inventory screens. Styling through themes and USS rules can be extremely powerful, though it sometimes introduces its own challenges when managing specificity and debugging style conflicts.","Transitions (scale, rotation), hover states (border on mouse over), and runtime theme switching come \"for free\" in UI Toolkit as opposed to traditional GameObjects and Prefabs.","That being said, UGUI is still a thing and support for it is on the roadmap!","UI Builder","If you are new to UI Toolkit, use these introductory videos to get you started."]}],[{"l":"Getting Started","p":["The best way to get started is by exploring the demos and examples.","Examples are isolated implementations of various use-cases. The idea is to separate the solution to a problem from all the potential noise. Examples are broken down by complexity into basic, intermediate, advanced (and grid, in PRO version), ranging from the simplest list inventory to container items and crafting benches. More examples will be added over time.","Examples List"]},{"l":"Example structure","p":["A typical example consists of a:","Scene","UI Document","Controller","Store","Minimal Example","Files are prefixed with the example name to prevent naming conflicts and to keep the examples self-container. This structure also makes it easier to copy an example into your own project and adapt it incrementally.","Some examples introduce custom behavior by extending the Store. For instance, splitting a stack or moving an item, are typically implemented inside a custom, reusable Store. You can read more about this in Architecture Overview."]},{"l":"How to use","p":["The recommended approach is to build your functionality by composing and extending existing pieces rather than modifying the framework code directly. Avoid editing demo code in place as updates to the package may overwrite your changes. Instead, treat the provided implementations as references and starting points.","Start by scaffolding your item system. Identify what is fixed (shared properties) and what differentiates items (stats, behaviors, categories). Create new Items and ItemBases for each meaningful item type. This allows you to define rule-based logic, like showing different tooltips for weapons versus armor, or preventing certain item types from being placed into specific equipment slots.","Next, identify which type of inventories your game should support - player inventory, stash, equipment, shop, crafting interface, etc. Create distinct types for each sufficiently different screen. This separation enables rule-driven behavior based on context: where an item originates, where it is placed, and what actions are permitted between those contexts.","For basic interactions, reuse an existing Store implementation. When your design requires new rules or workflows, create a custom Store derived from an example.","Introduce new Event types when necessary. For example, the Basic demo adds a custom event triggered after a successful crafting operation. That event is then consumed by a separate SFX controller to play a \"crafting\" audio clip.","Finally, create your UI Document and Controller, wire them together with your Store, and start with simple interactions between inventories. Add UI toggles, feedback, and additional views gradually. Iterate."]},{"l":"Guides","p":["To get started, check this guided timelapse of creating a simple inventory."]}],[{"l":"Architecture Overview \uD83D\uDEA7","p":["Bag Views update themselves in response to data changes.","Bags → hold data","Bags are collections of slots with rules defining what items can be stored and how.","Bags are typically defined in Controllers.","Bags notify any subscribers of data change (typically Bag Views).","Controllers → wire everything together","Controllers are MonoBehaviors.","Controllers query the UI Document for Bag Views, initialize them and attach Manipulators.","Here's a bottom-up bird's-eye view of the architecture:","Items are defined as Scriptable Objects.","Items are stored in collections called Bags (List, Set, Grid).","Manipulators → add UI Interaction Behaviors","Manipulators implement behaviors (drag-and-drop, tooltip).","Manipulators react to user input and publish events on the Event Bus.","Scripts other than the Store, can listen to events on the Event Bus and trigger their own behavior (play sounds, spawn objects).","Stores → define rules and mutate data","The Event Bus is a one-way messaging mechanism that decouples UI from logic and data.","The Event Bus is declared in the Store.","The framework follows a data-driven, event-based architecture. It keeps the data, logic and UI separate.","The Store behaves like a Singleton (it was a Singleton in v1).","The Store is a Scriptable Object.","The Store is the sole authority over data mutation.","The Store processes events and updates the Bags (either passed as event parameters or from its own context).","The system follows a unidirectional flow: user input generates events, the Store processes them, state updates, and views react to changes:","To sum up here are the major components and their responsibilities:","Views → render UI"]},{"l":"Bag","p":["Bags are pure data containers. Think of a Bag as the state of an inventory — nothing more.","A Bag stores items, does not contain UI logic but can define some gameplay rules. For example a bag can be configured to be remove only or accept only a certain type of items.","Because Bags are UI-agnostic, they can be reused across different interfaces or even outside UI contexts (e.g., crafting systems, world storage, containers inside items).","Examples: Equipment, Shop, Crafting Bench"]},{"l":"Item","p":["Items are based on ScriptableObject definitions (ItemBase) with runtime instances (Item).","Items describe what something is, not how it behaves in the UI.","This allows:","Easy editor configuration","Reusable item definitions","Custom item types (e.g., container items)"]},{"l":"Store","p":["Stores contain the logic of the system.","A Store:","Listens to events (e.g., Pick, Place, Drop)","Applies validation rules","Updates Bags","Publishes result events","For example, a Store decides whether an item can be moved, whether stacks can merge, what happens when an item is dropped into the world.","Stores define what is allowed, but they do not render anything. This makes behavior easy to customize — you can swap or extend Stores without changing Views."]},{"l":"Manipulator","p":["Manipulators are small, reusable interaction components attached to the root visual element. They are responsible for translating user input into high-level intent.","For example, Manipulators enable behaviors such as:","Drag and drop","Tooltips","Item rotation","Right-click / double-click actions","Slot highlighting","A Manipulator typically:","Listens to pointer or keyboard events.","Applies activation rules (e.g., modifier keys, mouse buttons).","Publishes an event to the event bus.","Importantly, Manipulators do not modify Bags directly. They only interpret input and emit intent."]},{"l":"Controller","p":["Controllers do not define gameplay rules. They simply connect the parts of the system together.","They:","Create or reference Bags","Inject Bags into Stores","Bind Bags to Views","Attach behavior in form of Manipulators"]},{"l":"Event Bus","p":["The event bus allows systems to communicate without direct references.","For example:","A Manipulator publishes a \"Pick\" event.","The Store reacts and updates a Bag.","The View re-renders automatically.","A sound system listens and plays an effect.","Because everything communicates through events:","Features can be added without modifying core systems.","Sound, VFX, and world spawning remain optional.","The framework stays modular and extensible."]}],[{"l":"Troubleshooting \uD83D\uDEA7"},{"l":"Discord Server","p":["Join the Discord server for additional support from the developer and the community."]},{"l":"Document doesn't look right in UI Builder","p":["If you open a document in UI Builder and it looks like it doesn't have the right styling, make sure to select the right theme from the dropdown.","Each demo comes with its own theme, grid examples use GDS Grid, and the rest - GDS Default.","In rare cases, themes may become corrupted during import. This is usually caused by an invalid asset path or GUID mismatch. If this occurs, please contact the developer for assistance."]},{"l":"Objects in the scene do not react to pointer","p":["Add Physics Raycaster component to main camera.","Add EventSystem component to scene hierarchy.","Make sure the UI Document is not blocking input. Try setting the blocking element's PickingMode to Ignore."]},{"l":"Bag doesn't show up in the inspector","p":["Make sure the class is marked as Serializable."]}],[{"l":"Roadmap","p":["Add support for UGUI","Add (some) controller support/examples","Various optimizations (pool events, change detection)","Add item sorting to Core","Enhance demos","Add a mobile demo","Improve Editor support","Add Scriptable Objects support"]}],[{"l":"v1 Docs","p":["The old website was moved here"]}],[{"l":"Bag \uD83D\uDEA7","p":["Bag is the abstract base class for all inventory containers. It defines the common contract for storing, validating, and manipulating Item instances. The base implementation intentionally does very little — most methods return Fail or Success by default. Concrete implementations (e.g., ListBag, GridBag) provide the actual behavior. Derived classes are expected to override the relevant methods."]},{"l":"CanAdd"},{"l":"CanRemove"},{"l":"Add"},{"l":"AddAt"},{"l":"AddRange"},{"l":"Remove"},{"l":"TransferAll"},{"l":"TransferOne"},{"l":"SplitHalf"}],[{"l":"ListBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"SetBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"GridBag \uD83D\uDEA7"},{"l":"Events"},{"l":"ItemChanged"},{"l":"ItemAdded"},{"l":"ItemRemoved"},{"l":"CollectionChanged"},{"l":"CollectionReset"}],[{"l":"Live demos","p":["Basic","Starter Template","ARPG","Backpack","FPS-Survival","Unnamed Game"]}],[{"l":"ARPG"}],[{"l":"Backpack"}],[{"l":"Basic"}],[{"l":"FPS Survival"}],[{"l":"Starter Template"}],[{"l":"Unnamed Game","p":["A \"backpack\" inventory proof of concept built on top of a mock-up by Yab Ninja (author and game creator)"]}]]