[[{"l":"Index","p":["Welcome"]}],[{"l":"Introduction","p":["This is a sample page demonstrating page metadata."]}],[{"l":"Core Concepts"}],[{"l":"Inventory Framework Documentation"},{"l":"Introduction","p":["The purpose of this package is to provide a versatile and extensible solution for creating inventories in Unity. Its design allows developers to quickly set up functional inventories while offering the flexibility to adapt to custom use cases. The framework supports a variety of inventory types, making it suitable for a wide range of games.","The predefined inventory types are:","List/Grid Inventory: A straightforward collection of items arranged as a list or a grid.","Equipment Inventory: Ideal for RPGs or games with wearable gear.","Advanced Grid Inventory: Supports items of varying sizes ( Not available in Lite).","Puzzle Inventory: A grid system for rotatable shapes ( Not available in Lite).","Built on UI Toolkit, it offers advanced styling and layout capabilities while avoiding the overhead of GameObjects and Prefabs. Learn more in the UI Toolkit documentation. It also comes bundled with an abstract yet powerful item system that minimizes setup while supporting diverse use cases.","This framework is currently targeted at programmers. It lacks designer-friendly features such as custom editors or Scriptable Objects, so some coding is required to implement custom functionality. Support for Scriptable Objects may come in the next update."]},{"l":"Getting started","p":["To get started, check out the 2 demos included in the Lite version - \"Minimal\" and \"Basic\".","The Minimal demo has the least amount of code needed to setup a working inventory. It is a great starting point to familiarize yourself with the fundamentals of the framework. It consists of one inventory, some items and the simplest behavior of moving items around.","The Basic demo is a Minecraft-inspired inventory featuring the following:","A main inventory window consisting of equipment, inventory and a consumables hot-bar","A vendor window where you can buy pre-defined items and sell items from your inventory.","A treasure chest window, which has some items that you can pick but cannot place anything back. You can also pick all at once.","A crafting bench window, which has slots for materials and an outcome slot. Placing materials in the correct order will populate the outcome slot. Picking the item from outcome slot will \"craft\" the item.","A stash window, which is an inventory you can store items in.","A way to drop items on the \"ground\".","A way to destroy items, by dragging them over a designated area.","All this is integrated in a minimalistic 3d scene.","![[images/Pasted image 20241127185839.png]]![[images/Pasted image 20250214194930.png]]"]},{"l":"Installation","p":["You can install the package from Unity Package Manager. There are no external dependencies."]},{"l":"Core Concepts","p":["The framework is built around several key concepts that define its structure and behavior. Understanding these will help you make the most of its features."]},{"l":"Item","p":["An Item is a data type that represents an individual object in an inventory. It is highly flexible and comprises two main components:","Base: Contains fixed properties like ID, name, and icon path.","Data: Holds dynamic properties such as quantity or rarity.","This architecture is heavily inspired from RPGs like Diablo and Path of Exile but the separation ensures adaptability to fit various gameplay scenarios."]},{"l":"Slot","p":["A Slot is a container that can either hold an Item or remain empty. Slots can enforce restrictions, such as allowing only specific types of items, by providing a function ( Accepts) that operates on Item type.","The base Slot type is extended into specialized slot types:","ListSlot: Index-based storage.","SetSlot: Named slots for equipment/wearable items.","GridSlot( not available in Lite): Grid-based position storage."]},{"l":"Inventory","p":["An Inventory manages a collection of Slots. Each inventory type comes with its own behavior and can enforce restrictions on accepted items. The base inventory type is Bag, a short and descriptive name.","The base Bag type is extended into specialized types:","ListBag: Contains a list of ListSlots","SetBag: Contains a list of SetSlots","GridBag( not available in Lite): Contains a 2D array of GridSlots as well as a list of GridItems"]},{"l":"Event Bus and Events","p":["The framework uses an Event Bus to decouple its components. Events are data containers describing actions, such as picking up an item. For example, a PickItem event includes the item itself, the source inventory and slot.","An event does not perform any actions itself, that falls under the responsibility of the Store."]},{"l":"Store","p":["Inspired by web technologies like Redux, the Store serves as the central hub for managing system state. It subscribes to events on event channels and performs necessary state updates. All changes to the system state flow through the Store, ensuring consistency and predictability."]},{"l":"Item Database","p":["This is your repository of item bases and all the types that fully describe and categorize them. For example an Apple is defined as a stackable, consumable basic item, while a Dagger is a 1-handed weapon, with Attack Damage and Attack Speed"]},{"l":"Behaviors","p":["The UI is decoupled from any interactivity logic. All logic is abstracted away in behaviors, like showing a tooltip on hovering an item, dragging an item to pick it up or showing a \"ghost\" version of the dragged item."]},{"l":"Technical Details","p":["The framework takes a functional programming approach, emphasizing simplicity and separation of concerns. It uses the a common \"good\" practice of Composition over Inheritance and not so common convention of Rules over Conditions(pattern matching).","C# Records are used to model data types. They offer concise syntax, value-like behavior and are immutable by default. The immutability aspect is particularly useful for View Components, as it simplifies determining whether a re-render is necessary.","A type's behavior is implemented via extension methods to keep the data structures clean and focused. This prevents behavior inheritance, which is a big pain-point in classic OOP design.","To ensure proper input validation when creating new instances, each data type comes with one or more factory functions. For example, an Item can be created by providing both an ItemBase and an ItemData or just an ItemBase. In either case, the item Id will be automatically generated.","To represent the absence of an object the null object pattern is employed in favor of the classic null reference. This means that most types have an associated void type: Item = NoItem which acts like the identity element from algebra. One of the main advantages of this approach is that an operation can be performed on a an item or a collection of items without the need of a null check beforehand. An operation like this will have no effect on the item, if it is a NoItem."]},{"l":"UI Toolkit Integration","p":["The framework leverages UI Toolkit for rendering inventory views. It provides a declarative way to define elements, their data, and their styles using C# and USS, while completely avoiding UXML. The reason for bypassing UXML is that data binding, referencing elements and working with the UXML asset, all come with levels of verbosity and complexity that drastically slow down productivity. This means, however, that the included visual components (inventories, windows, slots) cannot be viewed in Unity's UI Builder. You can still use the UI Builder to design own custom components if you prefer so. Since UI Toolkit is heavily based on web technologies, the framework proposes web-inspired nomenclature, such as:","DOM: Utility functions for managing elements.","DIV: A shorthand alias for VisualElement."]},{"l":"How it works","p":["![[Pasted image 20250214202313.png]]","From a birds eye view, the system consists of a data store, an event bus and UI When the user interacts with the UI, let's say picks an item from a slot, an event is put on the event bus.","The Store, having subscribed to the event, sends its data to a handler function which will update the bag.","Then, any view that is observing the bag will update itself."]},{"l":"How to Use the Framework","p":["Set up an inventory: Start by modifying or cloning one of the provided demos. Cloning ensures you donâ€™t lose your changes when updating the package.","Add new items:","Define a new item base in the Bases static class ( Basic/Inventory/Types.cs)","Use the ItemFactory.Create function to create the item.","Add the item to an inventory using AddItem or SetItems in the Store's Reset method.","Reference examples: Use the provided samples for guidance on extending functionality."]},{"l":"Troubleshooting","p":["Use the UI Toolkit Debugger ( Window UI Toolkit Debugger) to inspect the visual elements tree and its styles and classes.","![[Pasted image 20241127184237.png]]","Since UI Toolkit uses a form of CSS, it also inherits all the downsides of the cascading aspect - always check for unintended style propagation affecting your UI.","Use the included Debug editor windows to view the raw state of the system. These tools help identify whether issues originate from the data layer or the view layer.","![[Pasted image 20241127184644.png]]"]},{"i":"need-help","l":"Need Help?","p":["Join our Discord server to ask questions and get support from the community."]},{"l":"Roadmap","p":["Persistence: Save/load functionality using JSON and/or CSV.","Designer Tools: Support for Scriptable Objects and custom editors.","An advanced version(paid) is coming \"soon\". It will include","Grid inventory with varying item sizes.","Puzzle inventory with varying item shapes that can also be rotated.","Demos for grid-based inventories inspired by some popular games like Diablo, Backpack Battles, DayZ","Diablo / Path of Exile![[Pasted image 20241127190120.png]]","Backpack Battles![[Pasted image 20241127190304.png]]","DayZ![[Pasted image 20250214194839.png]]"]}],[{"l":"Live Demos"},{"l":"Live Demos"}],[{"l":"Backpack Game PoC"},{"l":"Basic"}],[{"l":"Basic"},{"l":"Basic"}],[{"l":"How to use","p":["I'll pin this comment for now but will move it to a dedicated read-only 'how-to' channel","The demos are both a showcase of what is possible and a good starting point for a custom inventory system. They are meant to be copy/pasted into projects and altered to need. You can start with the Minimal version and add the pieces you need or with Basic(I might rename this to Minecraft if the Asset Store allows it) and keep only what you need while adding your own stuff","Now, how can you tell what you need? First, there's the Store which is the one place where data is stored and handled. The Store has to listen to at least 2 events - pick item and place item. The handlers for these events will send the data to Core functions to process. Check either demo for an example of this. The case of moving an item between inventories (through a ctr+click for example) in the pick event (see Basic). The Store also needs to have a reference to the currently dragged item. It will be an Observable of type Item. Why observable item? So that parts of the system can react to the change without the need to explicitly subscribe to an Dragged Item Changed event. The Store is a singleton and there's nothing wrong with it - everything in it is read-only.","Then there's the type system and the items. The Minimal demo doesn't enhance on the type system in any way, and creates its items directly in the Store instance. The Basic however, declares a few extra base types and adds Rarity to item data type (see Basic/Inventory/Types.cs). All items have quantity and stackable fields - this felt like the one truly common aspect among all items regardless of inventory type, another one being the icon path, which is also present in base item data. Why is the item split into Base and Data? It's a common pattern ( https://en.wikipedia.org/wiki/Flyweight_pattern) that is both optimal and makes use of good-old composition over inheritance. For example an instance of an Apple doesn't need to carry around all the data that will never change, like its icon.","Thirdly there's the UI - you will need a UI Document attached to a GameObject in your scene, a Panel Settings asset, a Root UXML asset and a script that attaches the actual root of your inventory to the document. You can start by using the included renderers for items, slots and \"bags\" (inventories) and create custom views when you need them. For example, in Basic demo we define a custom ItemView and add a a background element to reflect the item's rarity. You are expected to create custom views for your screens and windows that will be composed of built-in, custom views and other UI elements (like buttons and text). See Basic/View/ChestWindow.cs for an example. Typically, the UI will only describe its structure and styling, and will have minimal behavior (like reacting to button clicks). All core behavior is abstracted away in extension methods (see next section for more on this). All demos come with a Theme file (see Resources/Basic/BasicTheme.tss). Technically you don't need one and could use the DefaultTheme, but the default theme is pretty ugly and you will end up customizing it anyway. You will notice that almost all of the styling is crammed in one big USS file (see BasicStyling.uss). Although not very elegant, I found it easier to search for selectors in one big file rather than multiple smaller ones. If the styling is completely unrelated to anything else, you can try putting it into a separate file and import it in the theme (see BasicTooltip.uss). Be your own judge in this regard, these are merely suggestions and personal preferences. If something doesn't look right it is probably because some style is missing or is not defined correctly. To help with debugging, each demo comes with a window that shows the raw state of the Store. To open it go to Tools Basic Debug. You are expected to alter this window (through code, of course) and add stuff you want to observe (see Basic/Editor/Debug.cs).","Lastly but equally important, you will need to attach some behaviors to the root layer of your document (see Basic/Views/RootLayer.cs). These behaviors are responsible for stuff happening on the screen, like showing an item being dragged or a tooltip appearing on hover. To give an example, WithRestrictedSlotBehavior(see Core/Behaviors/Behaviors.cs) is a behavior that observes the dragged item and reacts to mouse over/out events on all SlotViews.It then checks if the slot Accepts the item (this is defined on slot creation time) and marks the slot view as being in legal or illegal state by attaching a hardcoded class to the visual element (\"legal-action\"). This will show a red or green overlay on top of the slot icon (that is, if the styles are defined). In order to be able to pick (and place) items and see them move you will need to add a pick and a ghost item behavior. Currently there are two pick behaviors and one ghost behavior defined: WithClickToPickBehavior will pick an item on mouse down WithDragToPickBehavior will pick an item when it was dragged a minimum amount of pixels ( 32 by default) WithGhostItemBehavior watches mouse for movement and renders a view of the dragged item.","Why go to all these lengths with abstractions? It is my belief that the only way to build truly scalable systems is composing them from tiny composable blocks, like Legos. This level of decoupling allows for easier debugging when stuff breaks. It also covers some cases at low to no development cost where traditional approaches might struggle. For example, let's say, at first you only need to be able to pick up items, but then a requirement comes that you also need to be able to select items - you just add a new behavior (create one, if no such behavior exist by that time)."]}]]